Part 02. Operating System

[**Reference**](https://github.com/SSAFY-CS-STUDY/Tech_interview/tree/main/03.Operating_system)

<br>

## ⭐️ Process & Thread

#### 💡 프로세스와 스레드에 차이는 무엇인가?

- 프로세스는 **실행중인 프로그램**으로 OS로 부터 주소 공간, 파일, 메모리 등을 할당받을 수 있는 것을 말합니다.

  - 프로세스는 함수의 매개변수, 복귀 주소와 로컬 변수와 같은 임시 자료를 갖는 프로세스 스택과 전역 변수들을 수록하는 데이터 섹션을 포함
  - 프로세스 실행 중에 동적으로 할당되는 메모리인 힙을 포함

- 스레드는 **프로세스의 실행 단위**이다. 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유할 수 있습니다.

  - 스레드는 스레드 ID, 프로그램 카운터, 레지스터 집합, 그리고 **스택**으로 구성

  - 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 그리고 열린 파일이나 신호와 같은 운영체제 자원들을 공유

  - 멀티스레딩: 하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것, 이 경우 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 가짐

  - 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당

    

#### 💡 멀티 스레드의 장점 및 단점은 무엇인가?

- 장점
  - 프로세스를 이용하여 동시에 처리하던 일을 스레드로 구현할 경우 **메모리 공간과 시스템 자원 소모가 줄어들게 됩니다.**
  - 전역 변수의 공간 또는 Heap 영역을 이용하여 데이터를 주고받을 수 있기 때문에, 프로세스 간 통신 방법에 비해 스레드 간의 통신 방법이 훨씬 간단합니다.
  - 시스템의 throughput 이 향상되고 자원 소모가 줄어들며 자연스럽게 프로그램의 응답 시간이 단축됩니다.

- 단점

  - 프로세스와는 달리 스레드는 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용 중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있습니다. 따라서 동기화가 필요합니다.

  - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받음

    

#### 💡 멀티 프로세스 대신 멀티 스레드를 사용하는 이유

- 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 효율이 좋기 때문입니다.

- 자원의 효율성

  - 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, **프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어** 자원을 효율적으로 관리할 수 있습니다.
  - 스레드는 프로세스 내의 메모리를 공유하기 때문에 독립적인 프로세스와 달리 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어들게 됩니다.

- 처리 비용 및 응답 시간 단축

  - 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문에, 프로세스 간의 통신(IPC)보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어듭니다.

  - 프로세스 간의 전환 속도보다 스레드 간의 전환 속도가 빠릅니다.

    

#### 💡 자바 스레드란?

- 일반 스레드와 거의 차이가 없으며, JVM가 운영체제의 역할을 한다. **Main()안의 실행문들이 하나의 스레드**

- 자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.

  

#### 💡 Thread-safe가 뭐에요?

- **멀티스레드 환경에서 여러 스레드가 동시에 하나의 객체 및 변수(공유 자원)에 접근**할 때, 의도한 대로 동작하는 것을 말합니다.

- Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어해줘야 합니다.

- 동기화 기법으로는 Mutex나 Semaphore 등이 있습니다.

  

#### 💡 PCB의 역할 (Process Control Block)

- **OS가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳**으로, 프로세스의 상태 정보를 저장하는 구조체입니다.

- 프로세스 상태 관리와 문맥교환(Context Switching)을 위해 필요합니다.

- PCB는 프로세스 생성시 만들어지며 주기억장치에 유지됩니다.

  

<br>

## Scheduling

#### 💡 Context Switching이 뭐에요?

- Context Switching 이란 CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정을 말합니다.
- 프로세스가 준비 -> 실행, 실행 -> 준비, 실행 -> 대기 등으로 상태 변경될 때 발생합니다.



#### 💡 비선점방식과 선점방식을 설명해주세요.

- 비선점방식

  - 비선점(non-preemptive) 은 이미 할당된 CPU 를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법입니다.
  - FCFS, SJF 등

- 선점방식

  - 선점(preemptive) 은 특정 요건에 따라 각 프로세스의 요청이 있을 때 프로세스에게 분배하는 방식입니다.

  - 라운드 로빈(RR), SRT 등 

    

#### 💡 비선점 방식 FIFO, SJR, HRN의 차이

- FCFS (First Come First Served)
  - **대기 큐에 도착한 순서에 따라** CPU를 할당하고 일단 프로세스가 CPU를 차지하면 완료될 때까지 수행
  - 긴 작업이 짧은 작업을 오랫 동안 기다릴 수 있으며, 중요하지 않은 작업이 중요한 작업을 기다리게 할 가능성이 존재
  - 대화식 Real time 시스템에는 부적합

- SJF (Shortest - Job - First)

  - 준비 큐에서 기다리고 있는 프로세스 중에서 가장 **CPU 요구량이 적은 것**을 먼저 실행시켜 주는 방식
  - 평균 응답 시간을 최소화할 수 있으나, 실행 시간이 긴 프로세스가 CPU를 할당받지 못하고 계속해서 대기하는 무한 대기 현상이 발생할 수 있음

- HRN

  - 우선순위 계산식을 사용해서 **우선순위가 높은 프로세스**부터 자원을 할당하는 방식

    

#### 💡 선점 방식 SRT, RR 차이

- 라운드 로빈(RR)
  - 주로 우선순위 스케줄링(Priority scheduling)과 결합해 프로세스의 시간 할당량을 조절하는 방식으로 활용
  - FCFS 스케줄링을 기반으로 하여 CPU를 할당하되, 각 프로세스는 한 번에 쓸 수 있는 CPU 시간 크기(시간 할당량)이 지나면 시간 종료 인터럽트에 의해 CPU를 뺏기게 되는 방식
- SRT (Shortest Remaining Time)
  - 준비 큐에서 완료까지 남은 CPU 요구량이 가장 짧은 것을 먼저 실행시켜주는 방식
  - 실행 도중 남은 실행 시간이 더 적은 프로세스가 준비 큐에 들어올 경우, 현재 실행 중인 것을 중단하고 새 프로세스에게 CPU를 할당

<br>

## 메모리 관리 전략

#### 💡 교착상태 vs 기아상태

- 교착상태(데드락, Deadlock)

  - 여러 프로세스가 동일 자원 점유를 요청할 때 발생

  - 모든 스레드가 락이 풀리기를 기다리고 있기 때문에, 무한 대기 상태에 빠지게 된다. 이런 스레드를 교착상태에 빠졌다고 합니다.

- 기아상태

  - 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때 발생

  - 프로세스가 끊임없이 필요한 컴퓨터 자원을 가져오지 못하는 상황

    

#### 💡 교착 상태 4가지 조건

- 상호배제

  - 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구

  - 한 번에 한 프로세스만 공유 자원을 사용
  - 공유 자원에 대한 접근 권한이 제한. 자원의 양이 제한되어 있더라도 교착상태는 발생할 수 있음.

- 점유대기

  - 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림.

  - 공유 자원에 대한 접근 권한을 갖고 있는 프로세스가 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있음.

- 비선점

  - 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없음

  - 한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없음

- 순환대기

  - 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있음.

  - 두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재

    

#### 💡 외부 단편화와 내부 단편화란?

- 단편화

  - 기억 장치의 빈 공간 또는 자료가 여러 개의 조각으로 나뉘는 현상 (사용가능한 메모리가 충분히 존재하지만 할당이 불가능한 상황)

- 내부 단편화

  - 메모리를 할당할 때, 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비되는 현상

- 외부단편화

  - 메모리가 할당 및 해제 작업의 반복으로 작은 메모리가 중간중간에 존재할때, 사용하지 않는 메모리때문에 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황

- 해결방법

  - 페이징 기법 - 외부단편화 해결, 내부단편화 존재

  - 세그멘테이션 - 외부단편화 존재, 내부단편화 해결

  - 메모리 풀(Memory Pool) - 미리 필요한 메모리 공간을 할당받고 필요할 때마다 사용하고 반납하는 기법, 내부/외부 단편화 해결

    

#### 💡 페이징의 장점과 단점은?

- 페이징
  - 프로세스를 일정 크기인 페이지(page)로 잘라서 메모리에 적재하는 방식

- 장점

  - 외부 단편화 해결
  - 페이지 공유 가능, 메모리 공간의 효과적 활용
  - 페이지 보호 가능

- 단점

  - 페이지 테이블 사용으로 분할방식 대비 주소 결속에서 오버헤드 발생(속도저하)

  - 페이지 테이블의 메인메모리 저장으로 공간 낭비

    

#### 💡 메모리 단편화 해결 기법에 대해 설명하시오.

- 해결방법
  - 페이징 기법 - 외부단편화 해결, 내부단편화 존재

  - 세그멘테이션 - 외부단편화 존재, 내부단편화 해결

  - 메모리 풀(Memory Pool) - 미리 필요한 메모리 공간을 할당받고 필요할 때마다 사용하고 반납하는 기법, 내부/외부 단편화 해결

    

#### 💡 페이지 교체 알고리즘 중 3가지를 선택해서 설명해주세요.

-  FIFO(First-in First-Out)
  - 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘
- OPT(Optimal) 
  - 가장 사용하지 않을 페이지를 가장 우선적으로 내려 보내는 알고리즘
- LRU(Least-Recently-Used)
  - 최근에 사용하지 않은 페이지를 가장 먼저 내려 보내는 알고리즘

<br>

## 캐시

#### 💡 Cache Miss 종류

**1) Compulsory Miss**

- 최초 캐시 메모리가 초기화된 상태에서 발생하는 miss

**2) Capacity Miss**

- 전체적인 용량 부족으로 인한 miss

**3) Conflict Miss**

- Direct map이나 Set Associative 방식에서 같은 부분을 번갈아 가면서 사용하게 되어 발생하는 miss

  

### 캐싱 전략

#### 💡 Cache-Aside 는?

- 캐시를 옆에 두고 필요할 때만 데이터를 캐시에 로드하는 전략

#### 💡 Write-through란?

- 데이터를 추가하거나 업데이트 할 때, 캐시에 동시에 업데이트하는 전략

#### 💡 Read-Through는?

- 데이터베이스와 일렬로 배치되며, 캐시 미스가 발생할 때 데이터베이스에서 누락된 데이터를 로드하고 캐시를 채워 애플리케이션에 반환하는 전략

<br>

## 심화

#### 💡 파일 시스템이란

- 컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 유지 및 관리하는 방법

- 파일관리를 용이하게 하기위해 개발됨

- **파일 시스템과 DBMS 차이**

  - 파일 시스템은 데이터 무결성을 유지하기 어렵습니다.
  - 파일 시스템의 데이터 무결성을 유지하기 힘든 단점을 극복하고자 만들어진 것이 데이터베이스입니다

  

#### 💡 캐시와 레지스터의 차이점은 무엇인가요?

- 캐시와 레지스터는 어떤 명령이나 데이터를 저장해두는 저장 공간
- 캐시는 CPU와 별도로 있는 공간이며 메인 메모리와 CPU간의 속도 차이를 극복하기 위한 것
- 레지스터는 CPU안에서 연산을 처리하기 위해 데이터를 저장하는 공간
