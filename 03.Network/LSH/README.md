

## [OSI 7 layers와 TCP/IP 4 layer](#osi-7-layers와-tcpip-4-layers-답변)

#### 💡 [OSI 7 Layer 또는 TCP/IP Layer와 각 계층에 대한 설명을 해주세요.]()

#### 💡 OSI 7 Layer 또는 TCP/IP Layer에서 계층화하는 이유가 무엇인가요?
#### 💡 Encapsulation과 Decapsulation을 서로 비교하며 설명해주세요

#### 💡 IP 주소 및 MAC 주소는?

#### 💡 IPV4 vs IPV6 을 설명해주세요.
#### 💡 IPv4의 주소 부족현상을 해결하기 위해 현재 어떤 방법을 사용하고 있나요? - 심화

## [TCP와 UDP](#tcp와-udp-답변)

#### 💡 TCP와 UDP의 특징과 차이점을 설명해주세요.
#### 💡 TCP를 사용하는 대표적인 프로토콜은 무엇인가요?
#### 💡 3-Handshaking과 4-Handshaking의 과정을 설명해주세요.

#### 💡 3-way handshaking 과정에서 클라이언트가 서버가 보낸 ACK+SYN을 받지 못하면? - 서버 심화
#### 💡 UDP에서 신뢰도를 보장하는 방법을 설명해주세요.

## [HTTP와 HTTPS](#http와-https-답변)
#### 💡 HTTP와 HTTPS를 설명해주세요
#### 💡 HTTP의 단점을 설명해주세요
#### 💡 HTTP 1.0+와 HTTP1.1와 HTTP2.0 차이점은 무엇인가요?
#### 💡 HTTP는 왜 비연결성인가? - 서버 심화
#### 💡 모든 웹 페이지에서 HTTPS 를 사용하지 않는 이유를 설명해주세요.
#### 💡 비대칭키 또는 공개키 암호화 방식은 무엇인가요?
#### 💡 HTTP REQUEST 방식 중 GET과 POST의 차이을 설명해주세요.
#### 💡 GET, POST를 제외하고 다른 방식들을 설명해주세요.
#### 💡 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유?  
#### 💡 현대 웹 에서는 비연결성을 해결방법을 설명해주세요. - 서버 심화

## [로드밸런서](#로드밸런서-답변) - 서버 개발자만 답변할 것
#### 💡 로드 밸런싱을 설명해주세요.  
#### 💡 L4 로드 밸런싱과 L7 로드 밸런싱에 대해 설명하고, 차이를 말해보세요  
#### 💡 게이트웨이란?  
#### 💡 서버에 트래픽이 주어졌을 때 어떻게 응답속도를 개선할 수 있는가?  
#### 💡 프라이빗 서브넷과 퍼블릭 서브넷의 차이

## 01-2. Web of Network Overview
## [WEB](#web-답변)
#### 💡 url과 uri에 대해 각각 설명해주세요  
#### 💡 브라우저에 "www.google.com" 입력하면 어떤일이 일어날까요?  
#### 💡 RESTful API란 무엇인가요?  
#### 💡 Ajax는 무엇인가요?  
#### 💡 Ajax의 장점과 단점은 무엇인가요? - 웹 심화  
#### 💡 CORS는 무엇인가요?  
#### 💡 CORS preflight는 무엇인가요? - 웹 심화 
#### 💡 소켓이란 무엇인가요?  
#### 💡 DOM과 가상DOM - 웹 심화  
#### 💡 OAuth란 무엇인가요?  
#### 💡 SPA   

## [cookie와 session](#cookie와-session-답변)
#### 💡 cookie와 session에 대해 설명해주세요  
#### 💡 Session 동작 순서를 설명해주세요.  
#### 💡 cookie를 쓰는 이유를 설명해주세요  
#### 💡 세션 인증방식 단점  
#### 💡 토큰 인증방식
#### 💡 JWT   
#### 💡 토큰 인증방식 단점  
#### 💡 쿠키 인증방식 해결방안



<br>

## OSI 7 layers와 TCP/IP 4 layer 답변

#### 💡 OSI 7 Layer 또는 TCP/IP Layer와 각 계층에 대한 설명을 해주세요.

![image-20210708003725232](image/image-20210708003725232.png)

<br>

#### 💡 OSI 7 Layer 또는 TCP/IP Layer에서 계층화하는 이유가 무엇인가요?

통신 과정을 각 단계마다 볼 수 있고, 해당 계층에서 문제가 생기면 그 계층만 수정한다는 유지보수 측면에서 이점을 볼 수가 있습니다.

<br>

#### 💡 Encapsulation과 Decapsulation을 서로 비교하며 설명해주세요

먼저 캡슐화(Encapsulation)는 송신 데이터에 필요한 정보(헤더)를 붙여서 다음 계층에 보내는 기술을 의미합니다.

역캡슐화(Decapsulation)는 캡슐화의 반대개념으로, 헤더를 제거하는 것을 의미합니다.

* 참고

  캡슐화: 상위 -> 통신 프로토콜 정보 추가 -> 하위

  역캡슐화: 하위 -> 헤더 제거 -> 상위

  헤더에는 각 계층에서 수행한 정보들이 담겨있습니다. (데이터를 받을 상대계층에 대한 정보도 포함되어 있습니다.) 데이터의 내용이나 성격을 식별 및 제어하는 데에 사용됩니다.

<br>

#### 💡 IP 주소 및 MAC 주소는?

IP주소는 인터넷에 연결된 장치를 식별하는 고유한 번호의 집합입니다. IPv4와 IPv6가 있습니다.

* 참고: 각 네트워크를 인터넷 서비스 공급자(ISP)라고 하며 ISP에서 서비스를 구입하면 해당 ISP의 네트워크에 연결할 수 있습니다. 그런 다음 ISP에 연결된 다른 네트워크에 엑세스할 수 있습니다. 모든 ISP에는 IP 주소 풀이 있으며 서비스를 구매하면 IP주소가 할당됩니다.

MAC 주소는 장치에서 고유한 "네트워크 인터페이스"를 식별하는 주소입니다. IP주소는 ISP에 의해 할당되고 장치가 연결 및 해제될 때까지 재할당 될 수 있지만, MAC 주소는 물리적 어댑터에 연결되고, 제조업체에서 할당합니다.

MAC 주소는 12자리 문자열로서 0-9, A-F 까지의 문자로 이루어져 있습니다.

ex) `61:4A:34:1F:43:70`

처음 6자리는 어댑터 제조 업체를 나타내고, 마지막 6자리는 해당 특정 어댑터의 고유 식별 번호를 나타냅니다. MAC주소에는 장치가 연결된 네트워크에 대한 정보가 없습니다.

<br>

#### 💡 IP 주소와 MAC 주소의 차이점

IP 주소는 논리적인 주소 (LAN Card에 연결되어 있는 회선의 주소) - 네트워크 계층 

MAC 주소는 물리적인 주소 (장치의 네트워크 인터페이스 컨트롤러 (NIC)에 있는 주소) - 데이터 링크 계층

<br>

#### 💡 IPV4 vs IPV6 을 설명해주세요.

* IPv4는 3자 4개로 이루어져 있고, 각 3자는 0부터 255까지의 범위를 갖습니다.

  *  [0-255].[0-255].[0-255].[0-255] 

* IPv4의 확장성과 용량 면에서 한계가 생겼는데 이를 대체하기위해 등장한 것이 IPv6입니다.

  <img src="image/image-20210708202344067.png" alt="image-20210708202344067" style="zoom:50%;" />

  콜론으로 구분된 8개의 4자 문자열 세트처럼 보이며, 각 문자열에는 숫자와 소문자가 포함됩니다.

* IPv6는 효율적인 라우팅, 더 넓은 주소공간, 보안 내장, 처리 오버헤드가 줄어든 개선된 헤더 구조 등의 개선점을 가지고 있습니다.

  <br>

#### 💡 IPv4의 주소 부족현상을 해결하기 위해 현재 어떤 방법을 사용하고 있나요? - 심화

IPv4 시스템에서 IPv6 시스템으로 전환하고 있습니다.

<br>

## TCP와 UDP 답변

#### 💡 TCP와 UDP의 특징과 차이점을 설명해주세요.

**TCP**

<img src="image/81964786-10b4f200-9652-11ea-8b7a-959f2ef4177e.png" alt="TCP/UDP - 아주 작은 개발자의 블로그" style="zoom:150%;" />

* 전송 계층에 해당하는 프로토콜입니다. 인터넷 상에 데이터를 세그먼트로 보내기 위해 IP 프로토콜 위에서 연결형 서비스를 지원합니다. (연결형 서비스는 신뢰성을 보장하는 전송 방식입니다.)
* 흐름제어와 혼잡제어를 지원합니다.
  * 흐름제어: 데이터를 송신하는 곳과 수신하는 곳의 **데이터 처리 속도**를 조절해 수신자의 버퍼오버플로우를 방지합니다.
  * 혼잡제어: 데이터를 송신하는 곳의 **전송 속도를 낮춰** 네트워크 혼잡을 방지합니다.
* 특징
  * 데이터가 손실된 경우 재전송 요청을 하기 때문에 Streaming 서비스에 불리합니다.
  * 서버와 클라이언트 1대1로 연결됩니다. 
  * 전송 데이터의 크기가 무제한입니다.

**UDP**

![image-20210708212359167](image/image-20210708212359167.png)

* UDP도 전송 계층에 해당하는 프로토콜입니다. 데이터를 데이터그램 단위로 처리합니다. 데이터그램은 UDP가 논리적인 경로가 없기 때문에 독립적인 관계를 지닙니다. 이렇듯, 데이터를 서로 다른 경로로 독립적으로 처리하는 프로토콜을 UDP라고 합니다.
* 비연결형 서비스입니다.
* 특징
  * 비연결형이기 때문에 짧은 요청과 짧은 응답을 합니다. 연결형보다 속도가 빠르지만 패킷 손실 등의 신뢰성을 보장하지는 않습니다.
  * 연속성이 중요한 서비스(Streaming)에 이용됩니다.
  * 크기에 제한이 있습니다. 크기가 초과하면 잘라서 보냅니다.
  * 서버와 클라이언트가 1:1 , 1:N, N:M 등으로 연결될 수 있습니다.

![image-20210708212827843](image/image-20210708212827843.png)

<br>

#### 💡 TCP를 사용하는 대표적인 프로토콜은 무엇인가요?

네트워크 계층에 해당하는 IP 프로토콜과 함께 사용됩니다. TCP는 패킷을 추적 및 관리하는 역할을 수행하고, IP는 배달 역할을 수행합니다.

TCP/IP 4계층은 아래와 같습니다.

![TCP/IP와 계층구조 - wooody92&#39;s blog](image/91638346-eee94a80-ea49-11ea-9bd0-3d0b83b4bf39.png)

#### 💡 3-Handshaking과 4-Handshaking의 과정을 설명해주세요.

* 3-way handshake는 정확한 전송을 보장하기 위해 상대 컴퓨터와 사전에 세션을 수립하는 과정입니다. 클라이언트가 서버에 syn (synchronize sequence numbers)패킷 보내면 서버는 syn과 ack(acknowledgment) (syn+1 100이 넘어왔다면 101을 보낸다.)를 보내고 클라이언트가 다시 ack를 보내면 성공! (양쪽 모두 데이터를 전송할 준비가 되었다는 것을 의미합니다)
  ![image-20210708214909833](image/image-20210708214909833.png)

* 4-way handshake는 세션을 종료하기 위해 수행되는 절차로 클라이언트가 FIN플래그를 전송하면 서버가 확인했다는 의미로 ACK를 보내고, 서버가 통신이 끝나면 FIN 플래그를 전송합니다. 클라이언트가 ACK를 보내면 세션이 종료됩니다.
  ![image-20210708214925698](image/image-20210708214925698.png)

#### 💡 4-Handshaking에서 TIME_WAIT은 ?? 

잉여 패킷의 손실을 방지하기위해 FIN 플래그를 받아도 세션을 남겨두는 것(240초)을 의미합니다. 

서버에서 FIN을 전송하기 전에 클라이언트가 전송한 패킷이 라우팅 지연이나 패킷 유실로 인한 재전송 등으로 인해 해당 ACK 패킷이 FIN 패킷보다 늦게 도착하는 상황을 대비해야하기 때문입니다.

![image-20210708214754927](image/image-20210708214754927.png)



#### 💡 3-way handshaking 과정에서 클라이언트가 서버가 보낸 ACK+SYN을 받지 못하면? - 서버 심화

클라이언트는 서버에게 SYN 세그먼트를 보내고 시간을 잽니다. Timeout이 되기 전까지 서버에게 ACK, SYN 세그먼트가 오지 않으면 클라이언트는 다시 SYN 세그먼트를 보내고 수신을 대기합니다.

#### 💡 UDP에서 신뢰도를 보장하는 방법을 설명해주세요.

최소한의 오류 검출을 위해 UDP헤더의 CheckSum을 사용합니다.

![image-20210708214822493](image/image-20210708214822493.png)

<br>

## HTTP와 HTTPS 답변

#### 💡 HTTP와 HTTPS를 설명해주세요

HTTP에 암호화와 인증, 그리고 완전성 보호를 더한것이 HTTPS 입니다.

HTTP는 TCP에 직접 통신하는 방식이고 HTTPS는 HTTP와 TCP 사이에서 SSL이 통신하는 방식입니다. SSL은 Secure Socket Layer로써 정보를 암호화하고 이때 공통키 암호화 방식과 비대칭키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용합니다. (공통키를 비대칭키 암호화 방식으로 교환한 다음에 다음부터의 통신은 공통키 암호를 사용하는 방식) 

<br>

#### 💡 HTTP의 단점을 설명해주세요

- 보안이 취약합니다.
  - 평문 통신(암호화 되지 않은 통신)이기 때문에 도청이 가능합니다.
  - 통신 상대를 확인하지 않아 위장이 가능합니다.
  - 완전성을 증명할 수 없기 때문에 변조가 가능합니다.

<br>

#### 💡 HTTP 1.0+와 HTTP1.1와 HTTP2.0 차이점은 무엇인가요?

먼저, HTTP 프로토콜은 클라이언트-서버 간 데이터를 주고 받는 응용계층의 프로토콜입니다. HTTP 를 이용한 데이터 전달은 TCP세션 기반에서 이루어집니다.
![image-20210708220918289](image/image-20210708220918289.png)

* HTTP 1.0은 TCP connection당 하나의 URL만 fetch하며 매번의 request/response가 끝나면 연결이 끊기므로 매 번 필요할 때마다 다시 연결을 해야 하고 이로 인해 속도가 떨어집니다. 단순하게 open/operation/close의 방식을 취하고 있습니다. 또한, 한번에 얻어서 가져올 수 있는 데이터의 양이 제한되어 있습니다. 나아가 URL의 크기도 작습니다.

- HTTP 1.1은 하나의 연결에 하나의 요청을 처리하도록 설계되어 있습니다.

  - Persistent 기능을 이용하여 한개의 TCP 세션을 통해 여러개의 컨텐츠 요청이 가능합니다. (여러번의 request/ response를 주고 받을 수 있습니다.)

  - pipelining 기능을 가지고 있습니다. (응답 속도를 높임)

    ![image-20210708221050933](image/image-20210708221050933.png)

  - 한 인터넷 주소로 여러 web site의 연결이 가능합니다. 이때 client와 server는 Host request-header를 반드시 포함하고 있어야 하며 이 header를 주고 받아야 합니다. cache를 두어 성능을 향상합니다.

    ![image-20210708221132610](image/image-20210708221132610.png)

- HTTP 2.0은 하나의 연결에 여러개의 메시지를 동시에 주고 받을 수 있습니다. 요청 리소스간의 의존관계(우선순위)를 설정할 수 있습니다. 이 외에도 Server Push(여러개의 리소스를 포함하는 HTML문서 해석시에 필요한 리소르를 재요청하지 않고, Server Push 기법을 활용하여 해석), Header Compression(헤더 압축: 중복 헤더를 검출해 중복 헤더는 index값만 전송, 중복되지 않는 헤더는 인코딩하여 전송한다.) 기능을 가지고 있습니다.

  ![image-20210708221536285](image/image-20210708221536285.png)

  ![image-20210708221857651](image/image-20210708221857651.png)

<br>

#### 💡 HTTP는 왜 비연결성(Connectionless)인가? - 서버 심화

* 비연결성: **클라이언트와 서버가 한 번 연결을 맺은 후, 클 라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어 버리는 성질**을 말합니다.
* HTTP는 인터넷 상에서 불특정 다수의 통신 환경을 기반으로 설계되었습니다. 만약 서버에서 다수의 클라이언트와 연결을 계속 유지해야 한다면, 이에 따른 많은 리소스가 발생할 수 있습니다. 더 많은 연결을 위해 리소스를 줄이고자 비연결적인 특징을 갖습니다.
  * 물론 이로 인한 단점도 존재합니다. 서버는 클라이언트를 기억하고 있지 않으므로 동일한 클라이언트의 모든 요청에 대해, 매번 새로운 연결을 시도/해제의 과정을 거쳐야하므로 **연결/해제에 대한 오버헤드가 발생**한다는 단점이 있습니다.

<br>

#### 💡 HTTP의 무상태(Stateless)

Connectionless로 인해 **서버는 클라이언트를 식별할 수가 없는데**, 이를 Stateless라고 합니다. 이를 개선하기 위한 방법으로 쿠키와 세션이 있습니다.

<br>

#### 💡 모든 웹 페이지에서 HTTPS 를 사용하지 않는 이유를 설명해주세요.

- **HTTPS**는 설치 및 인증서를 유지하는 데 추가 비용이 발생
- 암호화하는 과정이 웹 서버에 부하를 줌
- **HTTP**에 비해 속도가 느림
- 인터넷의 연결이 끊긴 경우 재인증 시간이 소요

위와 같은 단점을 가지고 있기 때문!

<br>

#### 💡 비대칭키 또는 공개키 암호화 방식은 무엇인가요?

* **비대칭키**는 암호화, 복호화에 사용하는 암호키를 분리한 알고리즘 입니다. 자신이 가지고 있는 고유한 암호키로만 복호화할 수 있는 암호키를 대중에 공개하는 방식입니다.

* **대칭키**는 암호화, 복호화에 같은 암호키를 사용하는 알고리즘 입니다. 동일한 키를 주고받기 때문에 매우 빠르지만, 전달 과정에서 해킹 위험에 노출될 수 있습니다. 

<br>

#### 💡 HTTP REQUEST 방식 중 GET과 POST의 차이을 설명해주세요.

* GET: 클라이언트에서 서버로 정보를 요청할 때 사용되는 메서드이며, 예시로는 게시물 조회가 있습니다. GET 요청은 URL 주소 끝에 파라미터로 포함되어 전송되며 길이의 제한이 있습니다. 이 부분을 쿼리스트링이라고 합니다. 요청을 보낼때 결과가 달라지지 않는 멱등한 성질을 가지고 있습니다. 
  * 캐싱된 데이터를 응답할 수 있습니다.
  * 다른 사람에게 url을 복사해서 전달할 때 페이지 정보를 함께 전송해야하는 경우 GET을 사용해야합니다. POST의 경우 바디에 정보가 담기기 때문에 페이지 정보를 같이 전달할 수 없기 때문입니다.
* POST: 클라이언트에서 서버로 리소스를 생성하기 위해 데이터를 보낼 때 사용되는 메서드 입니다. 예시로는 게시물 작성이 있습니다. 전송할 데이터를 HTTP 메시지 바디 부분에 담아 서버로 전송합니다. 데이터 길이 제한이 없습니다. 요청을 할때마다 데이터베이스의 결과값이 달라지기 때문에 멱등하지 않습니다.
  * 객체(텍스트 박스 안에 있는 데이터, 라디오버튼에서 선택된 데이터)를 전달할 수 있다는 장점이 있습니다.
  * url에 데이터를 명시하지 않기 때문에 보안적으로 get보다 안전합니다.

<br>

#### 💡 GET, POST를 제외하고 다른 방식들을 설명해주세요.

* PUT: 포스트와 유사한 전송 구조를 가집니다. 서버에 지정한 콘테츠를 저장하기 위해 사용되고 CRUD에서는 update 요청에 많이 쓰이는 메소드입니다. (멱등)
* PATCH: 리소스의 부분만을 수정하는 데 쓰입니다.
* DELETE: 특정 리소스를 삭제합니다. (멱등)
* HEAD: GET 메서드 요청과 동일한 응답을 요구하지만, 서버 응답에서 헤더 정보이외에는 아무것도 보내지 않습니다. (웹서버 다운 여부 점검 등에 쓰입니다)
* OPTIONS: 시스템에서 지원되는 메소드 종류를 확인할 수 있습니다.

<br>

#### 💡 조회하기 위한 용도 POST가 아닌 GET 방식을 사용하는 이유?

GET은 요청을 보낼때 결과가 달라지지 않는 멱등한 성질을 가지고 있기 때문에 조회에 용이합니다.

<br>

#### 💡 응답상태 코드에 대해 설명해주세요. 

* 1xx: 진행중이라는 의미입니다.

* 2xx: 클라이언트 요청이 성공적으로 수행됨을 의미합니다.

  200 코드는 OK 즉, 요청이 성공적으로 수행함을 의미하고, 202는 Accepted를 204는 No content 사용자 요구를 처리했지만 전송할 데이터가 없음을 의미합니다.

* 3xx는 리다이렉트를 의미합니다. 

* 4로 시작하는 응답상태 코드는: 클라이언트의 잘못된 요청을 의미합니다.

  대표적으로 400과 404가 있습니다. 400은 배드리퀘스트이고, 404는 요청한 페이지가 없음을 의미합니다.

*  5로 시작하는 응답상태 코드는 서버쪽 오류로 인해 발생하는 상태코드입니다.

  500은 내부서버오류, 504는 게이트웨이 시간초과를 의미합니다.

  <br>

#### 💡 현대 웹 에서는 비연결성을 해결방법을 설명해주세요. - 서버 심화





세부 정리

* IP 주소

  * 인터넷 신분증이라고 생각할 수 있다. 인터넷에 접속하기 위해 필요한 주소

  * IP 주소를 발급 받는 과정
    **ICANN (전국) -> APNIC (아시아) -> KISA (한국) -> 통신사 -> 가정**

    <img src="image/image-20210708202146781.png" alt="image-20210708202146781" style="zoom:50%;" />

    <img src="image/image-20210708202208257.png" alt="image-20210708202208257" style="zoom:50%;" />



* ARP (Address Resolution Protocol)

  IP 주소를 MAC 주소로 변환해주는 프로토콜 (네트워크 계층 주소 -> 링크 계층 주소로 변환)

  반대로는 RARP가 있다.

* TCP 

  ![image-20210708211943912](image/image-20210708211943912.png)

  ![image-20210708211952673](image/image-20210708211952673.png)

refered by https://github.com/SSAFY-CS-STUDY/

## 참고

* 캡슐화 (https://ychae-leah.tistory.com/20)
* IP주소 
  * https://www.youtube.com/watch?v=IAS3U5ZiI8c&t=1s
  * https://www.ikpil.com/36
  * https://www.juniper.net/kr/ko/research-topics/what-is-ipv4-vs-ipv6.html
* HTTP1.0 vs HTTP 1.1 vs HTTP2.0
  * https://blog.daum.net/creazier/15310290
  * https://withbundo.blogspot.com/2021/02/http-http-10-http-11.html
  * https://it-mesung.tistory.com/159

* HTTPS
  * https://velog.io/@inyong_pang/HTTP-HTTPS
* HTTP
  * https://victorydntmd.tistory.com/286
