## Index

#### 💡Index란 무엇인가?

- 인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조입니다.

<br>

#### 💡Index의 자료구조는 어떤 것을 사용하나요?

- 인덱스의 가장 대표적인 자료구조는 해시 테이블과 B+ Tree입니다.

  해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조로 빠른 데이터 검색이 필요할 때 유용합니다.

  B+ Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조입니다.

<br>

#### 💡Index 사용시 장단점과 사용하면 좋은 경우와 나쁜 경우에 대해 설명하시오

- 인덱스의 장점은 테이블을 조회하는 속도와 성능을 향상시킬 수 있으며, 전반적인 시스템의 부하를 줄일 수 있다는 점입니다. 반면에, 단점은 인덱스를 관리하기 위해 저장공간이 필요하고, 인덱스를 관리하기 위한 추가 작업이 필요하다는 점입니다.

  인덱스를 사용하면 좋은 경우는 Insert, Delete, Update가 자주 발생하지 않는 컬럼이나, Join이나 Where 또는 Order by에 자주 사용되는 컬럼에서 사용하면 좋습니다.

  반면에, 인덱스를 사용하기 나쁜 경우는 DML(insert, Delete, Update)이 자주 일어나는 컬럼입니다.

<br>

#### 💡Index를 따로 설정하지 않은 경우의 테이블은 어떤가요?

- 인덱스를 따로 설정하지 않으면 기본적으로 PK가 인덱스로 설정됩니다. (?)

<br>

#### 💡모든 칼럼에 Index를 설정하면 좋나요?

- 아니요, 인덱스는 데이터의 중복도가 낮은 컬럼에 설정하는 것이 좋습니다. 특히 Insert, Delete, Update가 자주 일어나는 칼럼에 대해서는 인덱스를 사용하지 않는 것이 좋습니다.

<br>

#### 💡Index는 어디에 사용하는게 좋나요?

- 인덱스는 조회하고 검색하는 기능이 많을 때 활용한다면 성능을 최적화시킬 수 있습니다.

<br>

<br>

## 🏃🏻‍♀️ 정리

### 인덱스(Index)

- (검색을 위해) 임의의 규칙대로 부여된, 임의의 대상을 가리키는 무언가
- 추가적인 쓰기 작업과 저장 공간을 활용해 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

- 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕는다.

- 인덱스를 사용하지 않은 컬럼을 조회해야 하는 상황이라면, 전체를 탐색하는 Full Scan을 수행해야 한다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어진다.

<br>

#### 장점

- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

<br>

#### 단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
- 인덱스를 관리하기 위해 추가 작업이 필요하다.

- 만약 Create, Update, Delete가 빈번한 속성에 인덱스를 걸게 되면, 인덱스의 크기가 비대해져서 오히려 성능이 저하될 수 있다.

<br>

#### 인덱스(Index)를 사용하면 좋은 경우

- 규모가 작지 않은 테이블
- Insert, Update, Delete가 자주 발생하지 않는 컬럼
- Join이나 Where, Order by에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼



#### 인덱스(Index)의 자료구조

1. 해시 테이블(Hash Table)

   - (Key, Value)로 데이터를 저장하는 자료구조, 빠른 데이터 검색이 필요할 때 유용하다.

   ![Index_hash_table](./src/Index_hash_table.jpeg)

2. B+Tree

   - 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조. 모든 노드에 데이터(Value)를 저장했던 BTree와는 다른 특성을 가진다.
   - 리프노드(데이터 노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스 노드)들은 데이터를 위한 인덱스(Key)만 갖는다.
   - 리프노드들은 LinkedList로 연결되어 있다.
   - 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.
   - BTree의 리프노드들을 LinkedList로 연결하여 순차검색을 용이하게 했다.

   [InnoDB에서 사용된 B+Tree 구조]

   ![Index_B+Tree](./src/Index_B+Tree.png)



---

**[참고]**

[인덱스](https://mangkyu.tistory.com/96)

[우아한테크코스 10분 테코톡 "안돌의 Index"](https://youtu.be/NkZ6r6z2pBg)

[인덱스 구조](https://beelee.tistory.com/37)

[인덱스 구조 2](https://junhyunny.github.io/information/data-structure/db-index-data-structure/)