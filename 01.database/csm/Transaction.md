## Transaction

#### 💡트랜잭션이란 무엇이고 특성에 대해 설명하시오

- 트랜잭션은 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위입니다.

  트랜잭션은 원자성, 일관성, 독립성, 지속성이라는 4가지 특징을 갖고 있습니다.

  원자성은 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 하는 특성입니다.

  일관성은 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것입니다.

  독립성은 둘 이상의 트랜잭션이 동시에 실행되고 있을 때, 하나의 트랜잭션이 다른 트랜잭션의 연산에 끼어들 수 없다는 것입니다.

  지속성은 트랜잭션이 성공적으로 완료되었을 때, 결과가 영구적으로 반영되어야 한다는 것입니다.

<br>

#### 💡트랜잭션의 격리 레벨

- 트랜잭션의 격리 레벨은 크게 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE 4가지로 나뉩니다.

  READ UNCOMMITTED는 커밋되지 않은 데이터에 접근 가능한 레벨이고,

  READ COMMITTED는 커밋된 데이터에만 접근이 가능한 레벨입니다.

  REPEATABLE READ는 트랜잭션이 시작되고 종료될 때까지 한번 조회한 값은 같은 값이 조회되는 레벨입니다.

  SERIALIZABLE은 한 트랜잭션이 특정 테이블을 읽으면, 다른 트랜잭션은 해당 테이블을 추가, 변경, 삭제할 수 없는 레벨입니다.

<br>

#### 💡교착상태(Deadlock)이란 무엇인가?

- 교착상태란 여러 개의 트랜잭션들이 실행을 하지 못하고, 서로 무한정 기다리는 상태입니다.

<br>

#### 💡교착상태의 해결 방법

- 교착상태를 해결하는 방법에는 예방 기법과 회피 기법이 있습니다.

  예방 기법은 각 트랜잭션이 실행되기 전에 필요한 데이터를 모두 Lock 해주는 것입니다.

  회피 기법은 자원을 할당할 때 시간 스탬프를 사용해 교착상태가 일어나지 않도록 회피하는 방법입니다.

<br>

<br>

## 🏃🏻‍♀️ 정리

### 트랜잭션

- 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위

<br>

#### 특징 (ACID)

- **원자성** (**<u>A</u>**tomicity) : 트랜잭션이 데이터베이스에 모두 반영되던가(1), 아니면 전혀 반영되지 않아야 한다(0).
- **일관성** (**<u>C</u>**onsistency) : 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다.
  - 트랜잭션이 진행되는 동안 데이터베이스가 변경되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는 것이 아니라, 처음에 트랜잭션을 진행하기 위해 참조한 데이터베이스로 진행된다.
  - 이렇게 함으로써 각 사용자는 일관성 있는 데이터를 볼 수 있다.
- **독립성** (**<u>I</u>**solation) : 둘 이상의 트랜잭션이 동시에 실행되고 있을 때, 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없다.
  - 하나의 특정 트랜잭션이 완료할 때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.
- **지속성** (**<u>D</u>**urability) : 트랜잭션이 성공적으로 완료됐을 경우, 결과는 영구적으로 반영되어야 한다.

<br>

#### Commit, Rollback 연산

- **Commit** : 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성 있는 상태에 있을 때, 하나의 트랜잭션이 끝났다는 것을 알리기 위해 사용하는 연산
  - 이 연산을 사용하면 수행했던 트랜잭션이 로그에 저장된다.
  - 후에 Rollback 연산을 수행했던 트랜잭션 단위로 하는 것을 도와준다.

- **Rollback** : 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진 경우, 트랜잭션을 처음부터 다시 시작하거나, 트랜잭션의 부분적으로만 연산된 결과를 다시 취소한다.
  - 후에 사용자가 트랜잭션 처리된 단위대로 Rollback을 진행할 수 있다.

<br>

#### 트랜잭션 격리 레벨

- 일반적으로, 아래로 내려갈수록 트랜잭션간 고립 정도가 높아지며, 성능이 떨어진다.

- 일반적인 온라인 서비스에서는 READ COMMITTED나 REPEATABLE READ 중 하나를 사용한다.

  ex) Oracle = READ COMMITTED, MySQL = REPEATABLE READ

<br>

1. **READ UNCOMMITTED**

   : <u>커밋되지 않은 데이터에 접근이 가능</u>하다. N개의 트랜잭션이 하나의 공유 데이터에 접근해도 전혀 보호되지 않는다.

   - 이 수준에서는 Dirty Read라는 문제점이 발생할 수 있다.

2. **READ COMMITTED**

   : <u>커밋된 데이터만 조회</u>할 수 있다.

   - 그렇기 때문에 Dirty Read는 발생하지 않는다.
   - 이 수준 이하에선 Non-Repeatable Read라는 문제점이 발생할 수 있다.
   - Non-Repeatable Read : 하나의 트랜잭션이 같은 값을 조회할 때, 다른 값이 검색되는 현상

3. **REPEATABLE READ**

   : <u>트랜잭션이 시작되고 종료되기 전까지 한 번 조회한 값을 계속 같은 값이 조회</u>된다.

   - 트랜잭션 시작 전에 커밋된 내용에 한해서만 조회된다.
   - 데이터를 변경하려고 하면 UNDO 영역에 백업해두고 실제 레코드를 변경하게 된다.
   - 이 때는 Non-Repeatable Read는 발생하지 않는다.
   - 이 수준 이하에서는 <u>Phantom Read</u>가 발생한다.
   - Phantom Read : 마치 유령을 보는 것처럼 있던 데이터가 사라지거나 없던 데이터가 생기는 현상

4. **SERIALIZABLE**

   : 트랜잭션이 특정 테이블을 읽으면 다른 트랜잭션은 그 테이블의 데이터를 추가/변경/삭제할 수 없다.

   - 위에서 발생했던 Dirty Read, Non-Repeatable Read, Phantom Read는 발생하지 않는다.
   - 가장 강력한 격리 수준이며 데이터 정합성을 가장 잘 보장하지만, 동시 처리 성능이 가장 떨어진다.



#### READ COMMITTED와 REPEATABLE READ의 차이

- **Read Committed**는 **하나의 트랜잭션**에서 같은 쿼리를 두 번 실행하여 데이터를 조회할 때 값이 달라질 수 있다.

  커밋된 정보를 제약 없이 읽을 수 있기 때문에 **여러 스냅샷 버전**으로 읽는 것이 가능하기 때문이다.

- **Repeatable Read**는 하나의 트랜잭션 안에서 **하나의 스냅샷 버전**으로만 동작하기 때문에 같은 쿼리를 두 번 실행한다 할지라도 동일한 값이 유지된다.

<br>

<br>

### 교착상태

- 여러 개의 트랜잭션들이 실행하지 못하고 서로 무한정 기다리는 상태

- 기본적으로 데이터베이스에서는 트랜잭션들의 '동시성'을 제어하기 위한 기법으로 '로킹(Locking)'을 사용한다.

  이러한 로킹이 데이터가 엉망진창이 되는 것을 막아주지만 반면에, 그 부작용으로 교착 상태를 일으킬 수 있다.



#### 해결 방법

1. **예방 기법** : 각 트랜잭션이 실행되기 전에 필요한 데이터를 모두 로킹(Locking) 해주는 것
   - 예방 기법은 데이터가 많이 필요하면 사실상 모든 데이터를 전부 로킹해야 하므로, 트랜잭션의 병행성을 보장하지 못한다.
   - 몇몇 트랜잭션은 계속해서 처리를 못 하게 되는 <u>기아 상태</u>가 발생할 수 있다.
2. **회피 기법** : 자원을 할당할 때 시간 스탬프(Time Stamp)를 사용하여 교착상태가 일어나지 않도록 회피하는 방법
   - **Wait-Die 방식** : 다른 트랜잭션이 데이터를 점유하고 있을 때, <u>기다리거나(Wait)</u> <u>포기(Die)</u>하는 방식
     - 트랜잭션 Ti가 Tj에 의해 로킹된 데이터를 요청할 때, Ti가 먼저 들어온 트랜잭션이라면 기다린다(Wait).
     - 반면에, Ti가 나중에 들어온 트랜잭션이라면 포기(Die)하고, 나중에 다시 요청한다.
   - **Wound-Wait 방식** : 다른 트랜잭션이 데이터를 점유하고 있을 때, <u>빼앗거나(Wound)</u> <u>기다리는(Wait)</u> 방식
     - 트랜잭션 Ti가 Tj에 의해 로킹된 데이터를 요청할 때, Ti가 먼저 들어온 트랜잭션이라면 데이터를 선점한다(Wound).
     - 반면에, Ti가 나중에 들어온 트랜잭션이라면 기다린다(Wait).

<br>

---

**[참고]**

[트랜잭션](https://mommoo.tistory.com/62)

[트랜잭션 격리 수준](https://joont92.github.io/db/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80-isolation-level/)

[트랜잭션 격리 수준 2](https://private-space.tistory.com/97)

[트랜잭션 격리 수준 3](http://wiki.gurubee.net/pages/viewpage.action?pageId=21200923)

[READ COMMITTED와 REPEATABLE READ의 차이](https://mysqldba.tistory.com/334)

[교착상태](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ndb796&logNo=221243161017)
